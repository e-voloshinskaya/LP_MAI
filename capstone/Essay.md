# Реферат
## по курсу "Логическое программирование"

### студент: Волошинская Е.В.

## Математическая логика и логическое программирование: сравнение


## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

С появлением компьютеров люди стали задаваться вопросом, возможно ли автоматизировать процесс решения задач. Необходимо было выбрать систему для формального описания условий задач и необходимых действий компьютера. Сначала программировали на языке, воспринимаемом компьютером - на машинном коде, потом появились языки ассемблера - его команды прямо соответствуют отдельным командам машины или их последовательностям - а затем более удобные системы. Таким образом появилось множество разных стилей и парадигм программирования. В основу различных парадигм легли разные алгоритмические модели (императивные - машина Тьюринга, функциональное - лямбда-исчисление). Идея использовать математическую логику в качестве языка программирования возникла впервые в начале 70-x годов и была реализована в парадигме логического программирования, речь о котором пойдет дальше. Но для начала необходимо разобраться с понятиями.

## Исследуя понятия

### Математическая логика
Математическая логика является одной из древнейших наук. Она позволяет формализовать рассуждения человека: объекты предметной области, их свойства и отношения между ними записываются с использованием формальной логической системы, и исходя из известных суждений выводятся следствия, делаются заключения об истинности и ложности утверждений, выявляются противоречия и наоборот обосновывается непротиворечивость. Предметом математической логики по сути является все, что можно формально описать.

### Логическое программирование
Логическое программирование - это парадигма программирования, основанная на формальной логике. Что это значит?
В логическом языке программа содержит описание условия задачи на языке логики, а решение задачи происходит в процессе логического вывода и производится неявным образом встроенным в язык логическим интерпретатором. Это свойство языков, основанных на парадигме логического программирования, называется декларативность.
У данной парадигмы есть преимущества над более распространенным императивным программированием, в котором задачи решаются оперированием ячейками памяти ЭВМ и выполнением над объектами в памяти операции, составленные комбинацией примитивных операций машины.
Так, по сравнению с императивным программированием, логическое располагает наиболее естественным способом описания задачи. Кроме того, благодаря декларативности программы на логических языках не предполагают пошагового описания алгоритма решения, что в императивном программировании может быть сложной и слабо формализованной задачей.

Идеальный, естественный вариант логической программы - когда она является описанием задачи на языке логики предикатов и ее решение - запрос к предикату из описания. Пример:

Алгоритм Евклида поиска НОД чисел на Прологе почти неотличим от его математического определения.
```
gcd(a, b) = a, a=b
gcd(a, b) = gcd(a-b, b), a>b
gcd(a, b) = gcd(a, b-a), a<b
```
на Пролог записывается так:
```prolog
gcd(A, B, GCD) :- A = B, GCD = A.
gcd(A, B, GCD) :- A > B, A1 is A - B, gcd(A1, B, GCD).
gcd(A, B, GCD) :- A < B, B1 is B - A, gcd(A, B1, GCD).

?- gcd(18, 24, R). 
R = 6 ;
false.
```

## Явные сходства и различия
Перед детальным сравнением логического программирования и математической логики, следует отметить, что они действительно тесно связаны.
Во-первых, логическое программирование, как и мат. логика, является инструментом человека для представления знаний в формальном виде и манипулирования ими для получения некоторых результатов. А во-вторых, логическое программирование можно также рассматривать как науку, изучающую принципы логического вывода на основе исходных фактов и правил. То есть области изучения ЛП и МЛ как минимум пересекаются.

При этом существует фундаментальное различие, которое, собственно, является причиной для сравнения логического программирования и математической логики. Оно заложено в самом слове "программирование". То есть в отличие от математической логики, которая является наукой об основаниях математики, в названии "логическое программирование" уже есть некий дополнительный смысл, а именно связь с ЭВМ, с написанием программного обеспечения. Из этого факта следует целое множество различий. В частности, в отношении этих понятий: для логического программирования логика является инструментом, абстрактной вычислительной моделью. Поэтому же в основании логического программирования лежит не вся логика, а конкретная ее часть, логика предикатов дизъюнктов Хорна. Также, несмотря на разные точки зрения на этот вопрос, я считаю, что логическое программирование из-за этого фундаментального отличия не может быть ориентировано только на исследования в области математики, чтобы программы, написанные на логических языках, могли иметь и прикладной характер. Так как многие люди придерживаются той же точки зрения, то логические языки не просто повторяют заимствованную часть логики, но и дополняют ее нелогическими средствами, некоторые из которых я рассмотрю ниже.

## Сходства в представлении предметной области в мат. логике и логическом программировании

### Представление объектов
В математической логике, а именно в логике предикатов 1 порядка,
высказывания описываются кванторами (всеобщности ∀ и существования ∃), переменными, предикатами P(...), зависящими от конечного числа аргументов. Аргументы - это объекты предметной области, которые описываются тремя видами термов:
1. константы - обозначают некоторые конкретные уникальные объекты области.
2. переменные.
3. функциональные термы f(t_1, t_2, ..., t_n), где f - функтор, t_i - термы. В этом случае f имеет арность n.

Термин "логика первого порядка", таким образом, означает, что не могут применяться к предикатным и функциональным символам, а только к переменным.

Заметим, что:
- В то же время в языке лог. языках объекты также описываются константами, которые подразделяются на числа и атомы (строки), что соответствует константам в логике.
- В лог. языках также есть кванторы: в частности, запятая обозначает квантор всеобщности, точка с запятой - существования.
- Переменные в лог. языках аналогичны переменным в логике. Переменные-аргументы в программах лог. языков, входящие в правило (см. далее) один раз, могут задаваться анонимными переменными, которые отличаются от переменных логики тем, что их нельзя идентифицировать, но это не меняет их логического смысла. Связанные же переменные имеют свои уникальные (внутри одного правила, см. далее) имена.
- Составные термы логики эквивалентны структурам лог. языков. У них также есть понятие арности.
- Высказывания об объектах в математической логике задает предикат, который может принимать значения «истина» либо «ложь». Предикаты являются атомарными формулами или формулами логики предикатов первого порядка. В лог. языках предикаты соответствуют целевым утверждениям. Однако, забегая вперед, не все формулы логики предикатов возможно реализовать эквивалентно логическим в лог. языках.

Таким образом, мат. логика и логическое программирование описывают предметную область, используя схожие понятия.

### Представление высказываний в логическом программировании

Как описываются высказывания в логике предикатов первого порядка, было описано выше. А что насчет логических языков?

Программа в таких языках - конечная последовательность клауз. Высказывания задаются клаузами: фактами или правилами (условными предложениями). Предложением называется одно из трех: факт, правило, запрос.
- Факт - это предикатная структура, заканчивающаяся точкой. Эквивалент факту - это атомарная формула логики предикатов.
```
fact(X, Y).  ->   f(X, Y)
```
- Правило определяется как выражение, состоящее из предикатных структур A, B, C, ..., D, вида
```prolog
A :- B, C, ... D.
                   ->
                        B, C, ..., D ⊃ A  или ¬B ∨ ¬C ∨ ... ∨ ¬D ∨ A
```
Если правила/факты с одним и тем же функтором (с одинаковой арностью) записываются конечное число раз, большее 1, на языке логики это значит, что эквивалентный предиката является дизъюнкцией этих правил/фактов.
```
f(a).
f(c).
f(X) :- b(X).
f(X) :- a(X).
                 -> 
                           [(∃X)b(X) ⊃ (∀X)f(X)] ∨ [(∃X)b(X) ⊃ (∀X)f(X)] ∨ f(a) ∨ f(c)
```
Атом :- обозначает импликацию, только направлен в левую сторону. В случае, если одинаковые переменные структур присутствуют в обеих частях правила,
переменные из заключения правила квантифицируются универсально, из посылки - экзистенциально.
```prolog
parent(X, Y) :- child(Y, X, _).
                                ->
                                      (∃Y)(∃X)(∃A)child(Y, X, A) ⊃ (∀X)(∀Y)parent(X, Y)
```
Также в лог. языках существует запрос - это выражение, составленное из структур A, B, C, ..., D вида ?- A, B, C, ..., D.
Я предполагаю, что оно эквивалентно A, B, C, ..., D ⊃ R, где R - переменная-результат запроса.

Из вышесказанного можно сделать вывод, что для всех высказываний, которые возможно описать в лог. языках, существуют эквиваленты в логике предикатов.

## Различия в представлении высказываний

Разница в представлении высказываний, а точнее в возможностях их представления в логических языках, заметна. Почему все высказывания в Прологе имеют в логике предикатов вид B, C, ..., D ⊃ A?
Начнем с того, что вид формул-высказываний в логических языках ограничен.
На практике проблема выяснения общезначимости (формула верна при любых значениях аргументов из {0, 1}) и выводимости произвольной формулы логики предикатов неразрешима, невозможно однозначно определить, следуют ли нужные формулы из исходных. Это равнозначно тому, что ответ не будет найден, поэтому было решено, что модель для системы программирования должна быть менее выразительна и в основу логических языков была положена логика дизъюнктов Хорна. Дизъюнкт - это формула, состоящая из дизъюнкции атомарных формул. Дизъюнкт Хорна определяется как: B_1 ^ B_2 ^ ... ^ B_n ⊃ A (или ¬B_1 ∨ ¬B_2 ∨ ... ∨ ¬B-n ∨ A). Таким образом и выглядят правила лог. языков.
То есть мощность логики лог. языков меньше, чем мощность математической логики.

### "Чистое" логическое программирование. Нелогические средства
Существуют термины "чистое" логическое программирование, "чистый" Пролог. Под "чистотой" подразумевается (достаточно) точное соответствие описанию в рамках логической теории предикатов первого порядка (дизъюнктов Хорна).

Кооме того, существуют такие понятия, как процедурная и декларативная семантика программы. Декларативная определяет результат работы программы с точки зрения логики. Декларативный смысл программ на "чистом" языке не зависит от порядка предложений и целей в них. Процедурный смысл зависит также от того, как отношения обрабатываются системой, то есть он значительно зависит от порядка предложений и целей. Поэтому порядок может влиять на эффективность программы вплоть до бесконечных рекурсивных вызовов.

Так, изменение порядка в логически-эквивалентной программе поиска предка может привести к зацикливанию из-за радикального расхождения декларативной и процедурной семантик. Похожий пример мы рассматривали на лекции, поэтому я покажу, что есть еще один вариант этого предиката, также приводящий к зацикливанию. На лекции мы узнали, что предикат вида ancestor1(X, Y) зациклился. Причем я утверждаю, что из-за такого расположения правил он будет сразу зацикливаться на любых данных. Почему? Это связано с тем, что ancestor1(X, Y) - всегда самое первое правило, с которым Пролог будет унифицировать запрос, а его первый предикат ancestor1(Z, Y) будет снова вызывать это правило каждый раз с новой переменной. В таком случае значение переменной не будет найдено никогда.
Также можно составить предикат другого вида, ancestor2(X, Y). Он также будет логически эквивалентен исходному ancestor(X, Y). Однако в некоторых он способен найти решения. Это происходит потому, что вначале Пролог унифицирует запрос с правилом ancestor2(X, Y) :- parent(X, Y), то есть он сначала находит все факты из числа parent(X, Y), а потом для каждого следующего вызова ancestor1(Z_i, Y), также находит parent(Z_i, Y) (если такие факты существуют). Таким образом, предикат способен вывести верные решения, если есть факты parent(X, Y) с заданными в цели атомами. Однако когда правило ancestor2(X, Y) :- parent(X, Y). все же не выполнится (решения закончились или их не было), программа перейдет ко второму правилу, которое вызовет зацикливание аналогичным ancestor1(X, Y) образом.
```prolog
parent(john, amy).
parent(john, kate).
parent(kate, jeff).
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).

ancestor1(X, Y) :- ancestor1(Z, Y), parent(X, Z).
ancestor1(X, Y) :- parent(X, Y).

ancestor2(X, Y) :- parent(X, Y).
ancestor2(X, Y) :- ancestor2(Z, Y), parent(X, Z).

?- ancestor(john, jeff).
true ;
false.

?- ancestor1(john, jeff). 
ERROR: Stack limit (1.0Gb) exceeded

?- ancestor2(dave, may). 
ERROR: Stack limit (1.0Gb) exceeded

?- ancestor2(X, jeff).    
X = kate ;
X = john ;
ERROR: Stack limit (1.0Gb) exceeded
```

Процедурный смысл зависит также и от использования нелогических средств языка. В Прологе к ним относятся
- отсечение и not
- предикаты поиска всех решений findall, bagof, setof (не повторяющиеся)
- assert (добавить), retract (удалить) - добавление в программу или вычеркивание из нее предложений в процессе вычисления

### Отсечение и not(P)
Предикат not(P) на первый взгляд соответствует формуле логики ¬P, однако ¬P = 1, если P = 0. not(P) завершится успехом, если из известных фактов нельзя вывести P, то есть когда никакой информации о P нет. То есть семантики отрицаний в лог. языке и в логике не совпадают.
Кроме того, отрицание по бесконечному неуспеху (бесконечное дерево вывода) недоказуемо.

Отрицание, двойное отрицание и отсечение не позволяют генерировать значения. То есть если данные предикаты стоят в неверном месте предложения, результат не будет соответствовать логике, чистота программы нарушится.
```prolog
received('message 14').
received('message 15').
received('message 16').
unread('message 15').
unread('message 16').
?- received(A), not(unread(A)).
A = 'message 14'.

?- not(unread(A)), received(A).
false.
?- eng
```
Отсечение ограничивает автоматический перебор вариантов, находящихся ниже текущего правила, запрещает бэктрекинг. Оно повышает выразительность языка, но также может приводить к потере решений при неумном использовании.

## Вывод
Анализируя сходства и различия математической логики и логического программирования, я поняла, что на самом деле они действительно похожи. Описание задач на логических языках выглядит идентично описанию предикатов, терминология почти одинаковая. Математическая логика позволяет куда большее многообразие логических формул, в отличие от неизменных дизъюнктов Хорна с неявной кванторизацией во всех фактах, правилах и запросах логических языков. Но в этом, возможно, и есть их преимущество. Это делает язык куда более доступным для изучения различным людям, ведь для решения прикладных задач не требуется досконального знания логики предикатов. Также хорошо, что в логических языках все же есть нелогические средства, потому что писать программы без их использования бывает очень тяжело. Но есть и проблемы, которые замечаешь, когда начинаешь писать на конкретном языке и изучать теоретические основы. Реализация на вычислительной машине все-таки накладывает ограничения и в то же время создает свою специфику. Больше всего неприятно, что процедурная семантика даже в чистой программе часто не соответствует декларативной, особенно это раздражает в первое время. Но потом разбираешься, и даже понимаешь, как писать более эффективные программы. С учетом того, что данная парадигма имеет свои сильные стороны, такие как: автоматическое решение задач по формальному описанию, перебор вариантов и наличие бэктрекинга, естественная работа с деревьями, логическое программирование заслуживает свое место в мире.


## Список литературы
1. Сошников Д.В., Парадигма логического программирования.
3. Братко И. Программирование на языке Пролог для искусственного интеллекта. пер. с англ. - М.:Мир, 1990.
3. Набебин А.А. Логика и Пролог в дискретной математике.-М.:Изд-во МЭИ, 1996.
4. wikipedia.com
