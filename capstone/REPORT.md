# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Волошинская Евгения Владимировна

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |   24.4.22           |  3             |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получу навыки:
 - чтения формата генеалогических данных GEDCOM
 - написания программы-парсера на Python для обработки данных из файла
 - работы с большими данными


отточу мастерство программирования на Prolog и улучшу навыки письменной речи.

## Задание
(N = 9)
1. Преобразовать родословную европейской знати в формате GEDCOM в набор утверждений на языке Prolog, используя представление iv. с использованием предикатов father(отец, потомок) и mother(мать, потомок).
2. Реализовать предикат проверки/поиска следующих родственников - деверь (брат мужа).
Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве, например:
```prolog
?- relative(brother, ‘Петя’, X). 
X = ‘Вася’ 
?- relative(W,’Петя’,’Вася’). 
X = brother 
X = child – father     
% т.е. Вася является ребенком отца Пети 
X = child – mother  
% т.е. Вася является ребенком матери Пети
```

## Получение родословного дерева

В качестве данных для курсового проекта я выбрала файл из открытых источников "Родословная европейской знати", насчитывающий 33591 индивидуума из числа английской, немецкой, французской, польской, чешской и русской знати и 15996 семейных отношений между ними.

## Конвертация родословного дерева

Для конвертации родословного дерева я использовала язык Python, так как он прост, часто используется для обработки данных и я с ним немного знакома.

Вначале программа при помощи метода open(file, mode, encoding) открывает на запись 'w' файл data.pl в кодировке UTF-8. Также в data.pl записывается строка, позволяющая Прологу обрабатывать русский язык.
```python
data = open("data.pl", "w", encoding="utf-8")
data.write(":- encoding(utf8).\n\n")
```
Далее создаются словари (ключ-значение) для хранения пар 1) persons: ID - имя; 2) parents: ID ребенка - (ID матери, ID отца), так как обработка их в процессе чтения из-за последовательности данных в исходном файле и необходимого формата в Пролог-файле невозможна.
```python
person = {}  # key - id, data - person name
parents = {}
```
После этого происходит **построчное** чтение данных ('r') из gedcom-источника данных в кодировке Windows 1251.
Счетчик count позволяет начать считывание данных с 28 строки, так как до этого информация не связана с генеалогическим деревом.
Каждая строка проверяется на наличие в ней одного из слов (см. ниже) и в соответствии с заранее известным форматом таких строк оттуда извлекаются значения:
"INDI" - считывается ID человека;
"NAME" - считывается полное имя человека и **создается запись в словаре person, person[ID] = full_name + ID**, где ID - полученное на прошлом шаге значение;
**В большом генеалогическом дереве ID в имени оказался необходим, чтобы верно записать родственые отношения**
"FAM" - сбрасываются значения ID матери, отца, ребенка, сохраняющиеся локально в цикле for;
"HUSB" - считывается ID мужа из отношения FAM;
"WIFE" - считывается ID жены из отношения FAM;
"CHIL" - считывается ID ребенка из отношения FAM **и создается запись в словаре parents[child_ID] = (mother_id, father_id)**. Если одного из родителей нет, его ID=0, так как ID в промежутке [1, 33591].

```python
with open("royal_gen_20_11_2002.ged", "r", encoding="cp1251") as f: # open the source gedcom file (Windows 1251 encoding)
    for line in f:
        if count < 27:
            count += 1
            continue
        if "INDI" in line:  # find a person's id
            id_indi_end = line.index('@', id_indi_start)
            ID = line[id_indi_start : id_indi_end]
        elif "NAME" in line: # find a person's full name
            end_name = line.index('/')
            name = (line[name_name_start : end_name]).strip()
            surname = line[end_name + 1 : surname_name_end]
            string = (name + ' ' + surname).strip()
            full_name = string.replace('"', '\'')
            person[ID] = '"' + full_name + ' ' + str(ID) + '"' # strip deletes spaces if no surname
        elif "FAM" in line:  # resetting ids after family ends
            father_id = 0
            mother_id = 0
            child_id = 0
        # while "FAM" not in line, find family relations: father, mother, children ids
        elif "HUSB" in line:
            father_id = line[id_fam_start : id_fam_end]
        elif "WIFE" in line:
            mother_id = line[id_fam_start : id_fam_end]
        elif "CHIL" in line:
            child_id = line[id_fam_start : id_fam_end]
            parents[child_id] = (mother_id, father_id)
        count += 1
```
После завершения чтения конструкцией 'with open as ...' gedcom-файл закрывается автоматически.
Далее данные извлекаются из словарей и записываются в выходной файл data.pl:
ID отца и матери извлекаются по ключу-ID ребенка как 0-ой или 1-ый элемент кортежа значений (mother_id, father_id).
Проверяется корректность считанных семейных отношений, и если мать (отец) существует, в файл сначала записываются все факты mother(имя матери, имя ребенка), а потом father(имя отца, имя ребенка). В Прологе они не должны смешиваться.
После записи файл закрывается.
```python
for child in parents:
    if child != 0 and child in person:
        mother = parents[child][0]
        if mother != 0 and mother in person:
            data.write("mother(" + person[mother] + ", " + person[child] + ").\n")
for child in parents:
    if child != 0 and child in person:
        father = parents[child][1]
        if father != 0 and father in person:
            data.write("father(" + person[father] + ", " + person[child] + ").\n")

data.close()
```

## Предикат поиска родственника

Предикат dever(X, Y) задает связь X-Y, где Y - человек, который является братом мужу жены X.
Муж задается как человек, имеющий хотя бы одного ребенка совместно с женой, то есть одновременно существуют факты father(X, Child), mother(Y, Child).
Брат B имеет с человеком X хотя бы одного общего родителя и является мужчиной.
Пол определяется тем, кем является человек для своего ребенка: отцом или матерью.

Исходный код:
```prolog
:-['data.pl'].
male(X) :- father(X, _).
female(X) :- mother(X, _).

dever(X, Y) :- husband(X, H), brother(H, Y).
husband(W, H) :- mother(W, C), father(H, C).
brother(X, B) :-
	(father(F, X), father(F, B) ; mother(M, X), mother(M, B)),
	X \= B, male(B).
```

Поиск выдает много одинаковых ответов из-за сильного ветвления дерева решений. Примеры:
```prolog
?- dever("Олова 2515", Y).  
Y = "Олег Святославич, кн. Древлянский 2511" ;
false.

?- dever(X, "Олег Святославич, кн. Древлянский 2511"). 
X = "Олова 2515" ;
X = "Рогнеда Рогволодовна, кнж. Полоцкая 2514" ;
X = "Рогнеда Рогволодовна, кнж. Полоцкая 2514" ;
X = "Рогнеда Рогволодовна, кнж. Полоцкая 2514" ;
X = "Рогнеда Рогволодовна, кнж. Полоцкая 2514" ;
X = "Рогнеда Рогволодовна, кнж. Полоцкая 2514" ;
X = "Юлия Греческая 2512" ;
X = "Малфрида 2516" ;
X = "Аделья 2517" ;
X = "Аделья 2517" ;
X = "Аделья 2517" ;
X = "Анна Византийская 2518" ;
X = "Анна Византийская 2518" ;
X = "N Йонингенская 3165" ;
X = "N Йонингенская 3165" ;
X = "N Йонингенская 3165" ;
false.

?- dever("Мария Ларионовна Кашкарова 7480", Y).    
Y = "Петр Иванович Шаховской 4306" ;
Y = "Алексей Иванович Шаховской 4307" ;
Y = "Алексей Иванович Шаховской 4307" ;
Y = "Михаил Иванович Шаховской 4308" ;
Y = "Петр Иванович Шаховской 4306" ;
Y = "Алексей Иванович Шаховской 4307" ;
Y = "Алексей Иванович Шаховской 4307" ;
Y = "Михаил Иванович Шаховской 4308" ;
false.

?- dever(Z, "Петр Иванович Шаховской 4306").       
Z = "Татьяна Дмитриевна Арсеньева 7475" ;
Z = "Татьяна Дмитриевна Арсеньева 7475" ;
Z = "Мария Ларионовна Кашкарова 7480" ;
Z = "Мария Ларионовна Кашкарова 7480" ;
false.
```

## Определение степени родства

Первый шаг решения задачи - это собственно описание предикатов родственных отношений.
```prolog
male(X) :- father(X, _).
female(X) :- mother(X, _).

husband(H, W) :- mother(W, C), father(H, C).
wife(W, H) :- husband(H, W).

brother(B, X) :- father(F, X), father(F, B), X \= B, male(B).
brother(B, X) :- mother(M, X), mother(M, B), X \= B, male(B).

sister(S, X) :- father(F, S), father(F, X), X \= S, female(S).
sister(S, X) :- mother(M, S), mother(M, X), X \= S, female(S).

son(S, P):- (father(P, S); mother(P, S)), male(S).
daughter(D, P):- (father(P, D); mother(P, D)), female(D).

grandma(G, C):- mother(G, P), (mother(P, C); father(P, C)).
grandpa(G, C):- father(G, P), (father(P, C); mother(P, C)).

grandchild(C, G):- grandma(G, C); grandpa(G, C).
grandson(C, G):- male(C), grandchild(C, G).
granddaughter(C, G):- female(C), grandchild(C, G).
```
Дальнейшее решение задачи основано на поиске в пространстве состояний, где состояниями (вершинами графа) являются люди, а переходами (дугами графов) - описанные ниже отношения м/у людьми. При этом задача немного отличается от того поиска, который мы делали в 3 лабораторной, так как названия переходов так же необходимо помнить.
Описываем переходы:
```prolog
move(X, Y, father):-
    father(X, Y).
move(X, Y, mother) :-
    mother(X, Y).
move(X, Y, daughter) :-
    daughter(X, Y).
move(X, Y, son) :-
    son(X, Y).
move(X, Y, husband) :- 
    husband(X, Y).
    
% ... и т.д.
```
Для решения я использовала алгоритм поиска с итерационным заглублением. Так как необходим алггоритм, который сначала все-таки будет выдавать кратчайший путь и далее по нарастанию, то поиск в глубину не стоит использовать. Он справится с задачей разве что при хорошем расположении предикатов в файле. Я также не стала рассматривать поиск в ширину, так как исходные данные сами по себе очень большие, а этот метод поиска самый требовательный к памяти.

В итоге я немного изменила алгоритм: добавила максимальную глубину, после которой поиск остановится, и ввела в предикат path_id еще один аргумент-список, в котором будут сохраняться названия предикатов (путей).
```prolog
int(1).
int(M) :- int(N), M is N + 1.

path_id([X|T], X, [X|T], [], 0). 
path_id(Path, Finish, W, [R|T], N) :-
	N > 0,
    prolong(Path, Path1, R),
	N1 is N - 1,
	path_id(Path1, Finish, W, T, N1).

prolong([X|T], [Y, X|T], R) :-
	move(X, Y, R),
	not(member(Y, [X|T])).

search_id(Start, Finish, W, R) :- int(DepLimit), (DepLimit > 5, ! ; path_id([Start], Finish, W, R, DepLimit)).

relative(A, B, Res) :-
	search_id(B, A, _, Res).
```

Протокол работы:
(из-за того, что родственных связей много, дерево поиска получается очень большое, поэтому часть вывода я пропустила)
```prolog
?- relative("Николай I Павлович Романов 19503", "Александра Федоровна Прусская 19504", X).
X = [wife] ;
% Александра - жена Николая
% ...
X = [mother, son] ;
% Александра - мать сына Николая
% ...
X = [mother, daughter] ;
% Александра - мать дочери Николая
% ...
X = [grandma, grandson] ;
% Александра - бабушка внука Николая
X = [grandma, granddaughter] .
% Александра - бабушка внучки Николая

?- relative("Ольга Николаевна Романова 10300", X, [sister]).
true.
% У Ольги нет детей, поэтому неизвестно, может ли она являться сестрой

?- relative("Николай I Павлович Романов 19503", X, [brother]).
X = "Александр I Павлович Романов 16145" ;
X = "Александр I Павлович Романов 16145" ;
X = "Михаил Павлович Романов 16181" ;
% ...
X = "Михаил Павлович Романов 16181" ;
true. % Александр и Михаил - два (имеющих детей) брата Николая (всего их 4)
```

## Естественно-языковый интерфейс
--
## Выводы

Мне очень понравился курсовой проект. Было приятно и интересно обрабатывать данные, имеющие значение в реальном мире, а не абстрактные структуры, как чаще всего бывает в лабораторных. Я достигла поставленных целей: научилась работать с форматом gedcom, конвертировать данные файлов при помощи языка Python из gedcom- в Prolog-формат, усовершенствовала навыки письма и программирования на Prolog.
Я раньше не знала о формате gedcom и существовании огромных генеалогических gedcom-баз исторических данных. Курсовая заставила меня задуматься над тем, какие огромные возможности открываются в современном мире в сфере хранения генеалогических данных. Теперь можно делать это в цифровом формате, не теряя записанные на старых бумажках важные даты, места, истории предков, контакты дальних членов семьи. Мне всерьез захотелось заняться сбором данных о семье, ведь многое из того, что знают наши (у кого-то и пра-) бабушки и дедушки, будет забыто со временем.
