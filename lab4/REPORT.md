## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Волошинская Е.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует два основных подхода к обработке естественных языков (NLP): символический и статистический.

Символический подход основан на применении компьютером заданного набора правил к данным, с которыми он сталкивается. То есть он предполагает ручное кодирование набора правил в сочетании с поиском по словарю.

В статистическом подходе используется статистический анализ для автоматического изучения правил языка путем анализа больших корпусов типичных примеров реального мира.

Статистический подход имеет множество преимуществ перед более ранним символьным подходом, так как ручное написание правил бывает излишне сложным, неэффективным применительно к конкретным задачам и является неустойчивым к незнакомым и ошибочным входным данным. Однако при недостаточном количестве обучающих данных успешное применение статистического подхода невозможно, и это одна из причин, почему символьный подход все еще актуален.

Что касается искусственных языков, для них характерна строгая структура и конкретные правила синтаксиса, семантики и пр. Это делает обработку подобных языков проще.

Пролог использует символический подход. Он удобен для анализа языков, так как позволяет легко и коротко описывать формальные грамматики: синтаксис прост, правила отображаются на предикаты Пролога, а слова на атомы. Кроме того, Пролог удобен в проведении синтаксического анализа, так как чтобы представить выражения в виде дерева, не нужно реализовывать структуру дерево, как на традиционном языке, и другие необходимые для решения конструкции. Вместо этого интерпретатор пролога естественным образом преобразует программу в дерево и выполняет по нему перебор с возвратами.

## Задание

10. Реализовать разбор фраз языка, представляющих собой положительные и отрицательные высказывания. В результате предикат должен выдавать все атомарные глубинные структуры.

Запрос:
```prolog
?- decompose(["Саша", "любит", "игрушки", ",", "но", "не", "любит", "кубики", "и", "мячи"],X).
?- decompose(["Ира", "не", "любит", "стихи", "и", "прозы", ",", "а", "любит", "пьесы"],X).
```
Результат:
```prolog
X=likes("Саша", "игрушки").
X=not_likes("Саша", "кубики").
X=not_likes("Саша", "мячи").


X=not_likes("Ира", "стихи").
X=not_likes("Ира", "прозы").
X=likes("Ира", "пьесы").
```
## Принцип решения

Для решения данной задачи необходимо использовать такую грамматику:
```
G = <VT={Настя, Толя, Саша, Ира, ",", а, но, и, любит, не любит, игрушки, кубики, мячи, стихи, прозы, пьесы, театр, кино, сериалы, мультфильмы},
        VN={Decompose, Person, Info, Comma, But, VerbPh, Like, Nlike, Objs, And, Obj}, S=Decompose, P>, где VT - множество терминальных символов (слова), VN - множество нетерминальных символов (обозначения предикатов), S - начальный символ,  P - множество правил грамматики.
P:
Decompose -> Person Info
Info -> VerbPh Comma But VerbPh
VerbPh -> Like Objs | Nlike Objs
Objs -> Obj | Obj And Obj

Person -> Настя | Толя | Саша | Ира
Comma -> ,
But -> а | но
Like -> любит
NLike -> не любит
And -> и
Obj -> игрушки | кубики | мячи | стихи | прозы | пьесы | театр | кино | сериалы | мультфильмы
```

По грамматике составляем Пролог-программу. Для этого сначала задаем факты person(X), object(X). Факты but(X) и одиночные like, nlike, and и comma относятся скорее к базе знаний, а не базе данных, поэтому они указаны ниже.
```prolog
person("Настя").
person("Толя").
person("Саша").
person("Ира").

object("игрушки").
object("кубики").
object("мячи").
object("стихи").
object("прозы").
object("пьесы").
object("театр").
object("кино").
object("сериалы").
object("мультфильмы").
```
Далее составим правила в соответствии с грамматикой G:
```prolog
like(["любит"]).
nlike(["не", "любит"]).
comma(",").
but("но").
but("а").
and("и").
```
Предикат decompose(L, X) отделяет имя человека от фразы, проверяет его наличие в базе и передает его и оставшуюся часть фразы по отдельности в info, так как имя необходимо сохранить до самого конца работы программы, чтобы вывести ответ для X в виде фактов likes(имя, объект), not_likes(имя, объект).
```prolog
decompose([H|T], X) :- person(H), info(H, T, X).
```
Предикат info(Person, Text, X) отделяет одну из частей фразы (T1 до или T2 после запятой с союзом), в то же время проверяя правильность структуры предложения, и передает эти части предикату verbph по отдельности (правило "ИЛИ"), так как предикаты обрабатывают разные части фразы и могут иметь различные результаты, каждый из которых должен быть выведен.
```prolog
info(Person, Text, X) :-
	append(T1, [C, B | _], Text),
	comma(C), but(B), verbph(Person, T1, X).
info(Person, Text, X) :-
	append(_, [C, B | T2], Text),
	comma(C), but(B), verbph(Person, T2, X).
``
Предикат verbph(Person, Text, X) позволяет рассмотреть два случая: когда часть фразы положительная (получаем ответ X = likes(Person, Object)) и когда отрицательная (X = not_likes(P, O)). Он проверяет, что в начале фразы стоит "любит" или же "не любит" при помощи предикатов like(X) и nlike(X) и запускает поиск всех объектов object(X) при помощи предиката objs(Objects, Person, Object).
```prolog
verbph(Person, Text, likes(Person, Object)) :- append(L, Objects, Text), like(L), objs(Objects, Person, Object).
verbph(P, T, not_likes(P, O)) :- append(L, Os, T), nlike(L), objs(Os, P, O).
```
Первый предикат objs(Objects, Person, Object), который я реализовала, рекурсивно ищет все объекты, путем проверки каждого следующего слова на совпадение с фактами object(X). Это удобно, но, к сожалению, не полностью соответствует грамматике и не позволит использовать предикат decompose для проверки правильности предложения, так как количество объектов в предложении и вид разделителей между ними предикатом не ограничены.
```prolog
objs([H|_], _, H) :- object(H).
objs([_|T], P, O) :- objs(T, P, O).
```
Чтобы программа лучше соответствовала грамматике и могла использоваться для проверки предложений на правильность формата, я переписала предикат objs(Objects, Person, Object) так:
```prolog
objs([O], _, O) :- object(O).
objs([O, And, _], _, O) :- and(And), object(O).
objs([_, And, O], _, O) :- and(And), object(O).
and("и").
```
Для полного соответствия необходимо переписать правила 2-3 предиката objs так (но это излишне):
```prolog
objs([O1, And, O2], _, O1) :- object(O1), and(And), object(O2).
objs([O1, And, O2], _, O2) :- object(O1), and(And), object(O2).
```

## Результаты
```prolog
?- decompose(["Ира", "любит", "игрушки", ",", "но", "не", "любит", "мультфильмы", "и", "стихи"], X).
X = likes("Ира", "игрушки") ;
X = not_likes("Ира", "мультфильмы") ;
X = not_likes("Ира", "стихи") ;
false.

?- decompose(["Настя", "любит", "кино", "и", "мультфильмы", ",", "но", "не", "любит", "сериалы", "и", "театр"], X).
X = likes("Настя", "кино") ;
X = likes("Настя", "мультфильмы") ;
X = not_likes("Настя", "сериалы") ;
X = not_likes("Настя", "театр") ;
false.

?- decompose(["Толя", "любит", "театр", ",", "но", "не", "любит", "пьесы"],X).
X = likes("Толя", "театр") ;
X = not_likes("Толя", "пьесы") ;
false.

?- decompose(["Настя", "любит", "прозы", "и", "пьесы", ",", "но", "не", "любит", "стихи"], X).
X = likes("Настя", "прозы") ;
X = likes("Настя", "пьесы") ;
X = not_likes("Настя", "стихи") ;
false.
```
## Выводы

В процессе данной лабораторной работы я научилась обрабатывать языковые данные, используя символьный подход, основанный на написании грамматики языка. Я поняла, как преобразовывать грамматики в код на Прологе. Мне показалось, что Пролог - удобный инструмент для решения задач обработки языка, и несмотря на то, что сейчас такие задачи чаще решаются при помощи машинного обучения и нейросетей, для небольших задач или при малом объеме данных, его вполне можно использовать. В моем варианте написание программы обработки предложений на Прологе было также довольно простым и, как только я поняла, что программа полностью повторяет грамматику, потребовало лишь знания, как правильно описывать грамматику и применять предикат append. На мой взгляд, в данном типе задач Пролог положительно выделяется, в отличие от императивных языков, где пришлось бы написать очень много сложного кода.
