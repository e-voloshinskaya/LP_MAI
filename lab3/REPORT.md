## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Волошинская Е.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в пространстве состояний может применяться для решения задач, которые можно описать набором состояний объектов и набором переходов между этими состояниями, условие - начальным состоянием и цель - конечным. Тогда данные состояния будут эквивалентны вершинам графа, переходы между ними - дугам графа, а сама задача сведется к поиску пути между начальным и конечным состоянием, который выполняется одним из алгоритмов поиска путей в графе.

Так как поиск решения на Прологе основан на обходе дерева, то алгоритмы поиска реализуются на языке естественно, а подобные задачи, основанные на этих алгоритмах, решаются легко. Так, если при поиске была достигнута вершина (состояние), из которой дальше пути нет, то необходим откат до предыдущего состояния. Такой процесс - бэктрекинг - уже заложен в Прологе, поэтому нет необходимости писать дополнительный код. То есть Пролог является удобным инструментом решения задач методом поиска в пространстве состояний.

## Задание

2. Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. 
Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка 
и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

Для решения задачи используем алгоритмы поиска пути в графе: в глубину, в ширину и в глубину с итеративным погружением.

Вершинами данного графа являются состояния вида Xi = [Mi, Ci, wherei], где Mi и Ci - количество миссионеров и каннибалов на левом берегу соответственно и wherei -  расположения лодки (wherei = right или left).
Дуги в графе задает предикат move(X1, X2, Y), в котором Xi - вершины графа, Y - описание дуги в терминах задачи.
Путь (далее предикаты вида path_[название алгоритма]) - последовательность дуг move.
Решением задачи является кратчайший путь в графе из вершины-состояния [3, 3, left] в [0, 0, right].
```prolog
% в одну сторону
move([M1, C1, left], [M2, C1, right], '1 миссионер переплывает на правый берег') :-
	M1 > 0,  M2 is M1 - 1.
move([M1, C1, left], [M2, C1, right], '2 миссионера переплывают на правый берег') :-
	M1 > 1,  M2 is M1 - 2.
move([M1, C1, left], [M2, C1, right], '3 миссионера переплывают на правый берег') :-
	M1 = 3,  M2 is 0.
move([M1, C1, left], [M1, C2, right], '1 каннибал переплывает на правый берег') :-
	C1 > 0,  C2 is C1 - 1.
move([M1, C1, left], [M1, C2, right], '2 каннибала переплывают на правый берег') :-
	C1 > 1,  C2 is C1 - 2.
move([M1, C1, left], [M1, C2, right], '3 каннибала переплывают на правый берег') :-
	C1 = 3,  C2 is 0.
move([M1, C1, left], [M2, C2, right], '1 миссионер и 1 каннибал переплывают на правый берег') :-
	M1 > 0,  C1 > 0,  M2 is M1 - 1,  C2 is C1 - 1.
move([M1, C1, left], [M2, C2, right], '2 миссионера и 1 каннибал переплывают на правый берег') :-
	M1 > 1,  C1 > 0,  M2 is M1 - 2,  C2 is C1 - 1.

% в обратную сторону
move([M1, C1, right], [M2, C1, left], '1 миссионер переплывает на левый берег') :-
	M1 < 3,  M2 is M1 + 1.
move([M1, C1, right], [M2, C1, left], '2 миссионера переплывают на левый берег') :-
	M1 < 2,  M2 is M1 + 2.
move([M1, C1, right], [M1, C2, left], '1 каннибал переплывает на левый берег') :-
	C1 < 3,  C2 is C1 + 1.
move([M1, C1, right], [M1, C2, left], '2 каннибала переплывают на левый берег') :-
	C1 < 2,  C2 is C1 + 2.
move([M1, C1, right], [M2, C2, left], '1 миссионер и 1 каннибал переплывают на левый берег') :-
	M1 < 3,  C1 < 3,  M2 is M1 + 1,  C2 is C1 + 1.
move([M1, C1, right], [M2, C2, left], '2 миссионера и 1 каннибал переплывают на левый берег') :-
	M1 < 2,  C1 < 3,  M2 is M1 + 2,  C2 is C1 + 1.
move([M1, C1, right], [M2, C1, left], '3 миссионера переплывают на левый берег') :-
	M1 = 0,  M2 is 3.
move([M1, C1, right], [M1, C2, left], '3 каннибала переплывают на левый берег') :-
	C1 = 0,  C2 is 3.
```

Поиск пути в графе в глубину (DFS) не подходит для решения данной задачи, так как вариантов ее решения очень много, и первым из множества решений этого поиска является первая пройденная ветвь (последовательность их обхода зависит от порядка записи дуг графа), что не позволяет установить минимальность некоторого решения до того, как все они найдены и сравнены, а это при таком огромном количестве возможных путей проблематично.
DFS-алгоритм реализован в соответствии с лекцией. Он имеет три аргумента: начальный список пройденных вершин, конечную вершину и конечный список пройденных вершин. Для реализации используется вспомогательный предикат prolong(X, Y), который определяет условия валидности каждой следующей дуги пути.
```prolog
solve_dfs :-
	path_dfs([[3, 3, left]], [0, 0, right], Res),
	print_path(Res).

path0_dfs(X, Y, R) :- path_dfs([X], Y, R). 
path_dfs([Y|T], Y, [Y|T]).
path_dfs(PrevPath, Y, R) :-
	prolong(PrevPath, P1),
	path_dfs(P1, Y, R).

prolong([X|T], [Y, X|T]) :-
	move(X, Y, _),
	condition(Y),
	not(member(Y, [X|T])).
```

Поиск в ширину отлично подходит для данной задачи, так как предназначен для поиска кратчайших путей. Поиск происходит вширь, то есть перед тем как приступить к поиску вершин на расстоянии d+1, выполняется обход вершин на расстоянии d от начальной. Для реализации также используется вспомогательный предикат prolong(X, Y).

```prolog
solve_bfs :-
	path_bfs([ [[3, 3, left]] ], [0, 0, right], Res),
	print_path(Res).
    
path_bfs([[Y|T]|_], Y, [Y|T]).
path_bfs([P|QI], X, R) :-
	findall(Z, prolong(P, Z), T),
	append(QI, T, QQ), !,
	path_bfs(QQ, X, R).
path_bfs([_|T], Y, R) :- path_bfs(T, Y, R).

prolong([X|T], [Y, X|T]) :-
	move(X, Y, _),
	condition(Y),
	not(member(Y, [X|T])).
```

Поиск с итерационным заглублением основан на поиске в глубину, но глубина ограничена, и на каждой итерации глубина увеличивается, начиная с единицы. Данный поиск так же хорошо подходит для решения задачи, так как итерационное увеличение ограничения глубины позволяет узнать минимальную глубину, необходимую для успеха поиска.
```prolog
% Вспомогательный предикат int(X) для поиска с итер. загл.
 int(1).
 int(M) :- int(N), M is N + 1.

solve_id :-
	int(DepLimit),
	path_id([[3, 3, left]], [0, 0, right], Res, DepLimit),
	print_path(Res).

path_id([X|T], X, [X|T], 0).
path_id(P, Y, R, N) :- 
	N > 0,
	prolong(P, P1),
	N1 is N - 1,
	path_id(P1, Y, R, N1).
```

Печать результатов поиска происходит с конца списка вершин, так как они записываются в обратном порядке. Поэтому рекурсивный вызов печати стоит в начале тела функции.
```prolog
print_path([_]).
print_path([Y, X|T]) :-
 	print_path([X|T]),
 	move(X, Y, Action),
 	write(X), write(' -> '),
 	write(Y), write(': '),
 	write(Action), nl.
```

Для подсчета времени, которое занимает поиск решений для каждого алгоритма необходимо узнать разницу между временем начала и окончания поиска решения алгоритма. Это делается аналогично для всех алгоритмов поиска.
```prolog
solve_id :-
	get_time(T),
	int(DepLimit),
	path_id([[3, 3, left]], [0, 0, right], Res, DepLimit),
	print_path(Res),
	get_time(T1), write("Время: "), DT is T1 - T,
	write(DT), write(" sec"), nl.
```
## Результаты

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |                7               |      0.3 ms    |
| В ширину        |                5               |      2.5 ms    |
| ID              |                5               |       1 ms     |

Поиск в глубину:
```prolog
?- solve_dfs.
[3,3,left] -> [3,0,right]: 3 каннибала переплывают на правый берег
[3,0,right] -> [3,1,left]: 1 каннибал переплывает на левый берег
[3,1,left] -> [1,1,right]: 2 миссионера переплывают на правый берег
[1,1,right] -> [2,2,left]: 1 миссионер и 1 каннибал переплывают на левый берег
[2,2,left] -> [0,2,right]: 2 миссионера переплывают на правый берег
[0,2,right] -> [0,3,left]: 1 каннибал переплывает на левый берег
[0,3,left] -> [0,0,right]: 3 каннибала переплывают на правый берег
Время: 0.0003399848937988281 sec
true .
```

Поиск в ширину:
```prolog
?- solve_bfs.
[3,3,left] -> [3,0,right]: 3 каннибала переплывают на правый берег
[3,0,right] -> [3,1,left]: 1 каннибал переплывает на левый берег
[3,1,left] -> [0,1,right]: 3 миссионера переплывают на правый берег
[0,1,right] -> [1,1,left]: 1 миссионер переплывает на левый берег
[1,1,left] -> [0,0,right]: 1 миссионер и 1 каннибал переплывают на правый берег
Время: 0.002346038818359375 sec
true .
```

Поиск с итерационным заглублением:
```prolog
?- solve_id.
[3,3,left] -> [3,0,right]: 3 каннибала переплывают на правый берег
[3,0,right] -> [3,1,left]: 1 каннибал переплывает на левый берег
[3,1,left] -> [0,1,right]: 3 миссионера переплывают на правый берег
[0,1,right] -> [1,1,left]: 1 миссионер переплывает на левый берег
[1,1,left] -> [0,0,right]: 1 миссионер и 1 каннибал переплывают на правый берег
Время: 0.0011811256408691406 sec
true .
```

## Выводы
 
В процессе данной лабораторной работы я повторила знакомые алгоритмы обхода графов в глубину и в ширину, изучила новый - с итерационным заглублением - и познакомилась с их реализацией в Прологе. Лабораторная показала, что можно использовать данные алгоритмы на практике, для логических задач, в которых применим поиск решений в пространстве состояний. На мой взгляд, решать такие задачи на Прологе даже эстетически приятно, в отличие от императивных языков.

Что касается эффективного использования алгоритмов поиска,
- Поиск в глубину более естественен в реализации на Прологе, но его стоит применять, только когда нужно найти любое из решений и когда в графе нет петель.
- Поиск в ширину позволяет искать кратчайший путь, кроме того может использоваться при наличие петель, но существенно более затратен по памяти.
- Поиск с итерационным заглублением совмещает все плюсы обоих алгоритмов. С его помощью также возможен поиск кратчайшего пути, он более экономен по памяти, чем поиск в ширину, так как не хранит в каждый момент времени все уже пройденные вершины, а строит их заново до предела глубины на каждой итерации. При этом его временная сложность не сильно превышает сложность поиска в ширину.
