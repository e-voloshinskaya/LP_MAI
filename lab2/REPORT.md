## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Волошинская Е.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует множество методов решения логических задач, например, метод рассуждений, табличный метод, метод графов, метод кругов Эйлера, метод равносильных логических преобразований (с использованием алгебры логики).

Пролог, в отличие от императивных языков программирования, работает непосредственно с данными и логическими правилами, из которых и состоит условие логической задачи. То есть при решении логических задач на Прологе формат хранения данных и правил уже установлен языком, и программисту не нужно думать о том, как хранить данные в файле и внутри программы, какие структуры данных (строки, массивы, множества, деревья и т.д.) и синтаксические конструкции (циклы, ветвления) использовать для решения задачи, не нужно прописывать пошаговый алгоритм решения. Вместо этого задаются факты, правила и их взаимосвязь и формулируется цель (запрос), то есть Пролог позволяет программисту сосредоточиться на главном - на решении поставленной задачи.

## Задание

Один из пяти братьев разбил окно. Андрей сказал: Это или Витя, или Толя. Витя сказал: Это сделал не я и не Юра. Дима сказал: Нет, один из них сказал правду, а другой неправду. Юра сказал: Нет, Дима ты не прав. Их отец, которому, конечно можно доверять, уверен, что не менее трех братьев сказали правду. Кто разбил окно?

## Принцип решения

Решение строится на поиске не менее трех правдивых высказываний мальчиков путем перебора троек высказываний.
Каждое высказывание обозначается предикатом say(X, Y), который обозначает, что X считает виновным Y. То есть предикаты должны быть определены для X, соответствующих именам высказавшихся мальчиков (Андрей, Витя, Дима, Юра).
При помощи логических средств Пролога (логическое И - ",", логическое ИЛИ - ";", логическое отрицание - "not", неравенство - "\=") утверждения мальчиков записываются так:
```prolog
say("Andrey", "Vitya").
say("Andrey", "Tolya").

say("Vitya", Guilty):-
    Guilty \= "Vitya", Guilty \= "Yura".

say("Dima", Guilty):-
    (say("Andrey", Guilty), not(say("Vitya", Guilty)));
    (say("Vitya", Guilty), not(say("Andrey", Guilty))).

say("Yura", Guilty):-
    not(say("Dima", Guilty)).
```
Предикат true_says(X, Y) показывает, все ли высказывания людей из списка X правдивы. В случае успеха аргумент Y указывает на виновника.
```prolog
true_says([], _).
true_says([H|T], Guilty):-
        say(H, Guilty), true_says(T, Guilty).
```
Предикат solve(X) решает задачу. Он подбирает предполагаемого виновника из списка всех ребят, а также предполагаемого лжеца из списка высказавшихся ребят (Толя молчал), после чего, удаляя из списка говоривших возможного лжеца, проверяет правдивость утверждений оставшихся трех говоривших при помощи true_says. Таким образом перебором вариантов выявляется виновник - тот, для которого нашлись трое (или четверо включая предполагаемого лжеца) ребят, сказавших правду.
```prolog
solve(Guilty):-
    member(Guilty, ["Andrey", "Vitya", "Dima", "Yura", "Tolya"]),
    member(Liar, ["Andrey", "Vitya", "Dima", "Yura"]),
    delete(["Andrey", "Vitya", "Dima", "Yura"], Liar, Speakers),
    true_says(Speakers, Guilty), !.
```
Предикат answer() печатает ответ.

Эффективность решения: для минимизации операций перебора условие "не менее трех братьев сказали правду" упрощено до "три брата сказали правду", так как излишне проверять правдивость четвертого высказывания, если правдива тройка. Если ни одна тройка не правдива, то четверка также не будет правдива. При этом решения не теряются, так как перебором рассматриваются все возможные тройки.
Также эффективность решения достигается за счет использования перебора не перестановок объектов-высказываний, а их сочетаний, то есть максимально (при неудачном расположении объектов в списке) будет рассмотрено всего 4!/(3!1!) = 4 тройки (4 высказывания; количество вариантов при переборе - это количество способов выбора 1 элемента из 4), а не 4! = 24 (количество перестановок 4 элементов). Тогда общее количество рассматриваемых перебором случаев (аргументы true_says) - 4 * 5 = 20, где 5 - количество возможных виновников.
Сложность перебора - O(n*m), где n - количество ребят, m - количество высказавшихся.
Чтобы исключить дальнейший перебор после нахождения первого и, как известно, единственного решения, было добавлено отсечение после проверки true_says(Speakers, Guilty). То есть в случае, если в тройке есть неверное высказывание, true_says примет значение false, и перебор продолжится, а иначе поиск решений будет завершен.


Безопасность: программа не зациклится, так как задача предполагает конечное количество определенных фактов, предикаты member и delete порождают конечное количество веток решения, каждая из которых по определению предиката true_says с учетом специфики предиката says обязана завершиться успехом/неуспехом.


Непротиворечивость в данном случае достигается за счет отсутствия несоответствий между логикой решения задачи и реализацией этого решения средствами языка Пролог при условии, что исходная задача также имеет единственное решение.

## Выводы

В процессе данной работы я закрепила навыки написания предикатов на Прологе и работы со списками, а также разобралась с нюансами использования операций отрицания и отсечения и средств Пролога. Тяжело дался анализ решения, я не уверена, что сделала его правильно, но именно в процессе анализа я нашла способ оптимизации кода. Я была поражена, как просто и красиво логические задачи можно решить на Прологе. Несмотря на то, что решение основано на методе перебора, то есть происходит с генерацией и обработкой всевозможных вариантов, что не очень эффективно с точки зрения скорости, записывается оно очень коротко, совсем не как в привычных императивных языках программирования.
