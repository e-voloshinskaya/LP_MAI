% Первая часть задания - предикаты работы со списками

% ---- Длина списка:
% 1 аргумент - список, 2 аргумент - длина этого списка.
myLength([], 0).
myLength([_|Tail], N) :- myLength(Tail, N1), N is 1 + N1.


% ---- Принадлежность элемента списку:
%true, если X в списке L, false иначе. Ищет все вхождения элемента.

myMember(X, L) :- myRemove(L, X, _).

myMember2(X, [X|_]).
myMember2(X, [_|T]) :- myMember2(X, T).


% ---- Конкатенация списков:
% Порядок аргументов: список1, список2, результат конкатенации
myAppend([], X, X).
myAppend([L1|X], L2, [L1|L3]) :- myAppend(X, L2, L3).


% ---- Удаление элемента из списка:
% 1 арг - откуда удаляем, 2 арг - что удаляем, 3 арг - итоговый список
% Имеет несколько ответов, если вхождений больше 1. Если элемента нет в списке, результат - false.
myRemove([X|T], X, T).
myRemove([H|T], X, [H|T1]) :- myRemove(T, X, T1).


% ---- Перестановки списка
% 1 арг – исх. список, 2 арг – получ. перестановка. R – список после удаления элемента X.

% Операция внесения элемента в произвольное место списка
myAdd(X, L1, L) :- myRemove(L, X, L1).

myPermute([], []).
myPermute([X|L], P) :- myPermute(L, L1), myAdd(X, L1, P).

myPermute2([], []).
myPermute2(L, [X|T]) :- myRemove(L, X, R), myPermute2(R, T).


% ---- Список X является подсписком L (X - результат разбиения L на два подсписка)
mySublist(X, L) :- append(_, L1, L), append(X, _, L1).

% 1 аргумент - подмножество 2 аргумента
mySubset([], []).
mySubset([H|T1], [H|T2]) :- mySubset(T1, T2).
mySubset(H, [_|T2]) :- mySubset(H, T2).



% ------------------------------------------------------------------------------------------------------------------------

% Вторая часть задания - реализовать заданные предикаты двумя способами: с использованием стандартных пр-ов и без них.

% ---- 10. Вставка элемента в список на указанную позицию:
% Индексация с 1. Аргументы: элемент, позиция, список, новый список.

% без стандартных предикатов (в случае, когда индекс N больше длины списка, возвращает false)
ins(E, 1, T, [E|T]).
ins(E, N, [H|T], [H|T1]) :- N1 is N - 1, ins(E, N1, T, T1).

% используя length, append (в случае, когда индекс N больше длины списка, возвращает исходный список)
ins2(E, 1, [], R):- R = [E], !.
ins2(_, _, [], R):- R = [], !.
ins2(_, N, L, R):- N < 1, R = L, !.
ins2(_, N, L, R) :- length(L, R1), R1 < N - 1, R = L, !.
ins2(E, N, L, R) :-
	length(X, N1),
	N1 is N - 1,
	append(X, Y, L),
	append(X, [E], L1),
	append(L1, Y, R), !.


% ---- 15. Вычисление позиции первого отрицательного элемента в списке:
% Индексация с 1. Аргументы: список, позиция.

% без стандартных предикатов
first_neg([X|_], 1) :- X < 0.
first_neg([_|T], N) :- first_neg(T, N1), N is N1 + 1.

% используя length
first_neg2([X|_], 1):- X < 0.
first_neg2([X|T], R):- X >= 0, length(T, N), N > 0, first_neg2(T, R0), R is R0 + 1.

% пример на оба предиката:
% Вставка перед первым отрицательным элементом
ins_bef_1neg(E, L, R):- first_neg2(L, N), ins2(E, N, L, R).
% пример на myRemove и ins2:
% Перемещение элемента в списке
move(E, P, L, R):- myRemove(L, E, R0), ins2(E, P, R0, R).
